<!DOCTYPE html>
<html>
<head>
    <title>State Editor by Release</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Wed Jun 10 2015 16:45:36 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Jun 10 2015 16:45:36 GMT-0600 (MDT)";
        var CHECKSUM = 8662791441;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.AuditStore',{
    extend: 'Ext.data.Store',

    constructor: function(config) {
        var snaps_by_oid = {};
        if (config.snapshots){
            snaps_by_oid = this.aggregateSnapsByOidForModel(config.snapshots);
        }

        var data = [],
            fields = ['FormattedID','ObjectID',"Name","ChangedBy","DateChanged"],
            prevStateField = "_PreviousValues.ScheduleState",
            stateField = "ScheduleState",
            auditStateValue = "Accepted";


        _.each(snaps_by_oid, function(snaps, oid){
            var rec = {FormattedID: null, ObjectID: null, Name: null, ChangedBy: null, DateChanged: null, snap: null};
            _.each(snaps, function(snap){
                rec.FormattedID = snap.FormattedID;
                rec.ObjectID = snap.ObjectID;
                rec.Name = snap.Name;
                if (snap[prevStateField] != snap[stateField] && snap[stateField] == auditStateValue){
                    rec.ChangedBy = snap._User;
                    rec.DateChanged = snap._ValidFrom
                }
                //rec.snap = snap;
            });
            data.push(rec);
        });

        config.data = data;
        config.fields = [];
        config.pageSize = data.length;
        console.log('config',config);
        _.each(fields, function(field){
            config.fields.push({name: field});
        });

        this.callParent(arguments);

    },
    aggregateSnapsByOidForModel: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap.getData());

        });
        return snaps_by_oid;
    }
});
Ext.define("state-editors-by-release", {
    extend: 'Rally.app.TimeboxScopedApp',
    scopeType: 'release',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    fetchList: ['FormattedID','Name','_User','_PreviousValues.ScheduleState', "ScheduleState","_ValidFrom", "Iteration", "Project","Release"],
    wsapiFetchList: ['FormattedID','Name','ScheduleState','Project','Iteration','Release'],
    items: [
        {xtype: 'container', itemId: 'ct-header',cls: 'header', layout: {type: 'hbox'}},
        {xtype: 'container', itemId:'ct-display'},
        {xtype: 'tsinfolink'}

    ],
    onScopeChange: function(scope) {
        // render/refresh components
        this.logger.log('onScopeChange', scope);
        this._updateApp(scope.getRecord());
    },
    launch: function(){
        this.callParent();
        this._addComponents();
    },

    _addComponents: function(){
        if (this.getHeader()) {
            //Do nothing
        } else {
            this.add({xtype: 'container',itemId:'ct-header', cls: 'header', layout: {type: 'hbox'}});
            this.add({xtype: 'container',itemId:'ct-display'});
            this.add({xtype: 'tsinfolink'});
        }
    },
    _updateApp: function(releaseRecord){
        this.logger.log('_updateApp',releaseRecord);
        this._fetchData(releaseRecord);
    },

    _fetchData: function(release){

        this.down('#ct-display').removeAll();
        this.setLoading(true);

        var promises = [this._fetchCurrentReleaseRecords(release), this._fetchSnapshots()],
            releaseName = release.get('Name');

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(results){
                this.logger.log('_fetchData promises returned', results);
                 this._aggregateSnapshots(results[1], results[0], releaseName);
                this.setLoading(false);
            },
            failure: function(operation){
                this.setLoading(false);
                Rally.ui.notify.Notifier.showError({message: 'Error(s) loading data for release: ' + operation.error.errors.join(',')});
            }
        });
    },
    _fetchCurrentReleaseRecords: function(release){
        var deferred = Ext.create('Deft.Deferred'),
            filters = [{
                property: 'Release',
                value: null
            }];

        if (release){
            filters = [{
                property: 'Release.Name',
                value: release.get('Name')
            },{
                property: 'Release.ReleaseStartDate',
                value: release.get('ReleaseStartDate')
            },{
                property: 'Release.ReleaseDate',
                value: release.get('ReleaseDate')
            }];
        }

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'HierarchicalRequirement',
            fetch: this.wsapiFetchList,
            limit: 'Infinity',
            filters: filters
        });
        store.load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(records);
                }
            }
        });
        return deferred;
    },
    _fetchSnapshots: function(){
        var deferred= Ext.create('Deft.Deferred'),
            destinationState = "Accepted";

        if (this.transitionSnapshots){
            deferred.resolve(this.transitionSnapshots);
        } else {

           this.logger.log('_fetchSnapshots', destinationState);
           var store = Ext.create('Rally.data.lookback.SnapshotStore', {
                fetch: this.fetchList,
                limit: "Infinity",
                findConfig: {
                    "_TypeHierarchy": 'HierarchicalRequirement',
                    $or: [
                        {"_PreviousValues.ScheduleState": {$gte: destinationState}, "ScheduleState": {$lt: destinationState}},
                        {"ScheduleState": {$gte: destinationState}, "_PreviousValues.ScheduleState": {$lt: destinationState}}
                    ],
                    "_ProjectHierarchy": this.getContext().getProject().ObjectID
                },
                sort: {
                    "_ValidFrom": 1
                },
                hydrate: ["Project","Iteration","_PreviousValues.ScheduleState","ScheduleState","Release"]
            });
            store.load({
                scope: this,
                callback: function(records, operation, success){
                    this.logger.log('load successful?', success, records, operation);
                    if (success) {
                        this.transitionSnapshots = records;
                        deferred.resolve(records);
                    } else {
                        this.transitionSnapshots = undefined;
                        deferred.reject(operation);
                    }

                }
            });
        }
        return deferred;
    },
    _fetchStatePrecedence: function(stateField){
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var allowedValues = [];
                model.getField(stateField).getAllowedValueStore().load({
                    callback: function (records, operation, success) {
                        Ext.Array.each(records, function (allowedValue) {
                            //each record is an instance of the AllowedAttributeValue model
                            allowedValues.push(allowedValue.get('StringValue'));
                        });
                        deferred.resolve(allowedValues);
                    }
                });
            }
        });
        return deferred;
    },
    _aggregateSnapshots: function(snapshots, currentData, releaseName){

        var snaps_by_oid = {};
        if (snapshots){
            snaps_by_oid = this.aggregateSnapsByOidForModel(snapshots, currentData);
        }
        this.logger.log('aggregateSnapshots', releaseName);
        var data = [],
            prevStateField = "_PreviousValues.ScheduleState",
            stateField = "ScheduleState",
            auditStateValue = "Accepted";

        this._fetchStatePrecedence(stateField).then({
            scope: this,
            success: function(allowedValues){

                var user_oids = [],
                    auditStateIndex = _.indexOf(allowedValues, auditStateValue);

                _.each(snaps_by_oid, function(snaps, oid){
                    var rec = {FormattedID: null, ObjectID: null, Name: null, ChangedByOid: null, DateChanged: null, snap: null, Iteration: null, Project: null};
                    _.each(snaps, function(snap) {
                        rec.FormattedID = snap.FormattedID;
                        rec.ObjectID = snap.ObjectID;
                        rec.Name = snap.Name;
                        rec.Project = snap.Project || '';
                        rec.Iteration = snap.Iteration || '';
                        rec.ScheduleState = snap.ScheduleState;
                        rec.Release = '';
                        if (snap.Release){
                            rec.Release = snap.Release.Name || snap.Release;
                        }
                        var prevStateIndex = _.indexOf(allowedValues,snap[prevStateField]),
                            stateIndex = _.indexOf(allowedValues, snap[stateField]);

                        /**
                         * This needs to cover 3 scenarios:
                         * 1 - transition from a lower state to the audit state
                         * 2 - transition from a lower state to a state beyond the audit state
                         * 3 - transition from a higher state to the audit state
                         * Note, we do not want to capture editor when going from the audit state to a higher state
                         */
                        if (snap[prevStateField] && snap[prevStateField].length > 0 &&  //since we are also pulling current release records, we need to ignore what looks like the state transition for those.
                            prevStateIndex != stateIndex && stateIndex >= auditStateIndex &&
                            ((prevStateIndex < auditStateIndex) || (stateIndex == auditStateIndex))){

                            if (snap._User && !Ext.Array.contains(user_oids, snap._User)){
                                user_oids.push(snap._User);
                            }

                            rec.ChangedByOid = snap._User;
                            rec.DateChanged = snap._ValidFrom;
                        }
                        rec.snap = snap;
                    });

                    //They would like to not see last accepted if the story is not in an accepted state or above.
                    if ((_.indexOf(allowedValues, rec.ScheduleState) < auditStateIndex)){
                        rec.ChangedByOid = null;
                        rec.DateChanged = null;
                    }
                    if (rec.Release == releaseName){ //they only want to see records whose current release value matches the desired value.
                        data.push(rec);
                    }

                });

                var config = {};
                config["data"] = data;
                config["pageSize"] = data.length;

                this._hydrateUsers(config, user_oids);
            }
        });
    },
    _hydrateUsers: function(config, users){
        this.logger.log('_hydrateUsers',users);
        this._fetchUsers(users).then({
            scope: this,
            success: function(records){
                var userHash = {};
                _.each(records, function(r){
                    userHash[r.get('ObjectID')] = {
                        UserName: r.get('UserName') || '',
                        FirstName: r.get('FirstName') || '',
                        LastName: r.get('LastName') || '',
                        ObjectID: r.get('ObjectID')
                    };
                });

                _.each(config.data, function(rec){
                    var oid = rec["ChangedByOid"] || 0;

                    if (oid > 0){
                        rec["UserName"] = (userHash[oid] ? userHash[oid].UserName || '' : 'User ' + oid );
                        rec["FirstName"] = (userHash[oid] ? userHash[oid].FirstName || '' : '');
                        rec["LastName"] = (userHash[oid] ? userHash[oid].LastName || '' : '');
                    }
                });

                this._buildGrid(config);

            },
            failure: function(errorMsg){
                Rally.ui.notify.Notifier({message: errorMsg});
            }
        });
    },
    _buildGrid: function(config){
        this.logger.log('_buildGrid',config);

        var store = Ext.create('Rally.data.custom.Store', config);

        if (this.down('#rally-grid')){
            this.down('#rally-grid').destroy();
        }

        var grid = this.down('#ct-display').add({
            xtype: 'rallygrid',
            itemId: 'rally-grid',
            store: Ext.create('Rally.data.custom.Store', {
                data: config.data,
                autoLoad: true,
                remoteSort: false,
                remoteFilter: false,
                pageSize: config.pageSize,
                width: '75%'
            }),
            columnCfgs: [
                {dataIndex: 'FormattedID', text: 'FormattedID'},
                {dataIndex: 'Name', text: 'Name', flex: 1},
                {
                    dataIndex: 'ChangedByOid',
                    width: "20%",
                    text: 'Accepted By',
                    renderer: function(v,m,r){

                        if (r.get('UserName')){
                            return Ext.String.format("{0} {1} ({2})", r.get('FirstName'), r.get('LastName'), r.get('UserName'));
                        }
                        return '';
                    }
                },
                {
                    dataIndex: 'ScheduleState', text: 'Schedule State'
                },
                {dataIndex: 'DateChanged', text: 'Last Accepted Date', width: '20%',renderer: function(v){
                    if (v){
                        return Rally.util.DateTime.formatWithDefaultDateTime(Rally.util.DateTime.fromIsoString(v));
                    }
                    return '';

                }},
                {
                    dataIndex: 'Project', text: 'Project', renderer: function(v){ if (v){return v.Name || '';}}
                }

            ],
            showPagingToolbar: false
        });
    },

    _fetchUsers: function(users){
        var deferred = Ext.create('Deft.Deferred');

        var minObjectID = Ext.Array.min(users),
            maxObjectID = Ext.Array.max(users),
            filters = [];

        filters.push({
            property: 'ObjectID',
            operator: '>=',
            value: minObjectID
        });
        filters.push({
            property: 'ObjectID',
            operator: '<=',
            value: maxObjectID
        });

        filters = Rally.data.wsapi.Filter.and(filters);

        var user_store = Ext.create('Rally.data.wsapi.Store',{
            model: 'User',
            fetch: ['UserName','FirstName','LastName','ObjectID'],
            filters: filters
        });
        user_store.load({
            scope: this,
            callback: function(records, operation, success){
                if (success) {
                    deferred.resolve(records);
                } else {
                    deferred.reject("Error hydrating users:  " + operations.error.errors[0]);
                }
            }
        });
        return deferred;
    },
    aggregateSnapsByOidForModel: function(snaps, currentData){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object, put the current wsapi data last.

        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){

            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap.getData());

        });
        Ext.each(currentData, function(r){
            var oid = r.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(r.getData());
        });
        return snaps_by_oid;
    }
});

            
               Rally.launchApp('state-editors-by-release', {
                   name: 'State Editor by Release'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>